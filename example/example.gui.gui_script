local druid = require("druid.druid")
local druid_settings = require("druid.settings")

local lang = {
	locale_text = "Localized"
}
local start_x = 300
local page_width = 600
local cur_page = 1
local max_page = 3



local function log(self, params)
	print(params)
end


local function setup_druid(self)
	-- two different way of exernal component regesstration
	druid.comps["my_mega_test_comp"] = require "druid.base.text"
	druid.register("my_custom_component", {})

	druid_settings.is_debug = true
	druid_settings.play_sound = function(name)
		sound.play("sounds#" .. name)
	end
	druid_settings.get_text = function(text_id)
		return lang[text_id]
	end
end


local function change_page(self, delta)
	cur_page = cur_page + delta
	cur_page = math.max(1, cur_page)
	cur_page = math.min(cur_page, max_page)

	gui.animate(gui.get_node("center"), "position.x",
		start_x - (page_width * (cur_page - 1)), gui.EASING_OUTSINE, 0.1)
end

local function init_pages(self)
	self.druid:new_button("prev", change_page, -1)
	self.druid:new_button("next", change_page, 1)
end


local function init_buttons(self)
	self.druid:new_button("button_1", log, "button 1")

	self.druid:new(druid.comps.button, "button_2", log, "button 2")
end


local function init_progress(self)
	local val = 0.4
	local simple = self.druid:new_progress("simple_fill", "x", val)
	local vert = self.druid:new_progress("simple_vert_fill", "y", val)

	simple:set_steps({0, 0.3, 0.6, 1}, function(self, step)
		print("STEP:", step)
	end)

	timer.delay(0.4, true, function()
		val = val + 0.1
		if val > 1 then
			simple:empty()
			vert:empty()
			val = 0
		end
		simple:to(val)
		vert:to(val)
	end)

	local rich = self.druid:new_progress_rich("rich_fill", "rich_red", "rich_green", "x")

	rich:set_to(0.3)

	local rich_val = 0.3
	self.druid:new_button("rich_add", function()
		rich_val = rich_val + 0.1
		rich:to(rich_val)
	end)
	self.druid:new_button("rich_dec", function()
		rich_val = rich_val - 0.1
		rich:to(rich_val)
	end)
end


local function init_grid(self)
	local prefab = gui.get_node("prefab")

	-- 4 items per row
	local grid = self.druid:new_grid("grid_1", prefab, 4)
	grid:set_anchor(vmath.vector3(0))
	grid:set_offset(vmath.vector3(2, 2, 0))
	for i = 1, 16 do
		local node = gui.clone(prefab)
		grid:add(node)
	end

	local val = 0
	timer.delay(0.1, true, function()
		val = val + 0.5
		grid:set_offset(vmath.vector3(val))
		if val > 4 then
			val = 0
		end
	end)


	-- 1 item per row
	local grid2 = self.druid:new_grid("grid_2", prefab, 1)
	grid2:set_offset(vmath.vector3(0, 10, 0))
	for i = 1, 4 do
		local node = gui.clone(prefab)
		grid2:add(node)
	end


	local grid3 = self.druid:new_grid("grid_3", prefab, 10)
	grid3:set_anchor(vmath.vector3(0))
	grid3:set_offset(vmath.vector3(5, 0, 0))
	for i = 1, 4 do
		local node = gui.clone(prefab)
		grid3:add(node)
	end
end


function init(self)
	setup_druid(self)
	self.druid = druid.new(self)

	init_pages(self)
	init_buttons(self)
	init_progress(self)
	init_grid(self)

	self.druid:new_android_back(log, "some")
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)
end